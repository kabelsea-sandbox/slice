// Code generated by MockGen. DO NOT EDIT.
// Source: ./container.go

// Package slice is a generated GoMock package.
package slice

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	di "github.com/kabelsea-sandbox/slice/pkg/di"
)

// MockContainerBuilder is a mock of ContainerBuilder interface.
type MockContainerBuilder struct {
	ctrl     *gomock.Controller
	recorder *MockContainerBuilderMockRecorder
}

// MockContainerBuilderMockRecorder is the mock recorder for MockContainerBuilder.
type MockContainerBuilderMockRecorder struct {
	mock *MockContainerBuilder
}

// NewMockContainerBuilder creates a new mock instance.
func NewMockContainerBuilder(ctrl *gomock.Controller) *MockContainerBuilder {
	mock := &MockContainerBuilder{ctrl: ctrl}
	mock.recorder = &MockContainerBuilderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContainerBuilder) EXPECT() *MockContainerBuilderMockRecorder {
	return m.recorder
}

// Has mocks base method.
func (m *MockContainerBuilder) Has(target interface{}, options ...di.ResolveOption) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{target}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Has", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has.
func (mr *MockContainerBuilderMockRecorder) Has(target interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{target}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockContainerBuilder)(nil).Has), varargs...)
}

// Provide mocks base method.
func (m *MockContainerBuilder) Provide(constructor di.Constructor, options ...di.ProvideOption) {
	m.ctrl.T.Helper()
	varargs := []interface{}{constructor}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Provide", varargs...)
}

// Provide indicates an expected call of Provide.
func (mr *MockContainerBuilderMockRecorder) Provide(constructor interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{constructor}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Provide", reflect.TypeOf((*MockContainerBuilder)(nil).Provide), varargs...)
}

// MockContainer is a mock of Container interface.
type MockContainer struct {
	ctrl     *gomock.Controller
	recorder *MockContainerMockRecorder
}

// MockContainerMockRecorder is the mock recorder for MockContainer.
type MockContainerMockRecorder struct {
	mock *MockContainer
}

// NewMockContainer creates a new mock instance.
func NewMockContainer(ctrl *gomock.Controller) *MockContainer {
	mock := &MockContainer{ctrl: ctrl}
	mock.recorder = &MockContainerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContainer) EXPECT() *MockContainerMockRecorder {
	return m.recorder
}

// Has mocks base method.
func (m *MockContainer) Has(target interface{}, options ...di.ResolveOption) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{target}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Has", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has.
func (mr *MockContainerMockRecorder) Has(target interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{target}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockContainer)(nil).Has), varargs...)
}

// Invoke mocks base method.
func (m *MockContainer) Invoke(fn di.Invocation, options ...di.InvokeOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{fn}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Invoke", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Invoke indicates an expected call of Invoke.
func (mr *MockContainerMockRecorder) Invoke(fn interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{fn}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Invoke", reflect.TypeOf((*MockContainer)(nil).Invoke), varargs...)
}

// Resolve mocks base method.
func (m *MockContainer) Resolve(into interface{}, options ...di.ResolveOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{into}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Resolve", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Resolve indicates an expected call of Resolve.
func (mr *MockContainerMockRecorder) Resolve(into interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{into}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resolve", reflect.TypeOf((*MockContainer)(nil).Resolve), varargs...)
}
